#include<stdio.h>
#include<iostream>
#include<queue>
#include<conio.h>
using namespace std;

#define RH 1 // cây con phải cao hơn ( lệch phải )
#define EH 0 // cây con trái bằng cây con phải ( cân bằng )
#define LH -1 // cây con trái cao hơn ( lệch trái )

typedef int ItemType; // khai báo ItemType có kiểu int

struct AVLNode
{
	int balFactor; // chỉ số cân bằng
	ItemType Info;
	AVLNode* Right;
	AVLNode* Left;
};

typedef struct AVLNode* AVLTree;

// khoi tao danh sach rỗng
void CreateAVLTree(AVLTree& T)
{
	T = NULL;
}

// khởi tạo node
AVLNode* CreateAVLNode(int x)
{
	AVLNode* p = new AVLNode;

	if (p == NULL)
	{
		printf("\n khong du bo nho de cap phat !!");
		return NULL;
	}
	// gốc ( root ) // node đầu tiên
	p->balFactor = EH;
	p->Info = x;
	p->Left = NULL; // chưa có cây
	p->Right = NULL; // chưa có cây

	return p;
}

void rotateLL(AVLTree& T) // quay đơn LL
{
	AVLNode* T1 = T->Left;
	T->Left = T1->Right;
	T1->Right = T;
	switch (T1->balFactor)
	{
	case LH:
		T->balFactor = EH;
		T1->balFactor = EH;
		break;
	case EH:
		T->balFactor = LH;
		T1->balFactor = RH;
		break;
	}
	T = T1;
}

void rotateRR(AVLTree& T) // quay đơn RR
{
	AVLNode* T1 = T->Right;
	T->Right = T1->Left;
	T1->Left = T;
	switch (T1->balFactor)
	{
	case RH:
		T->balFactor = EH;
		T1->balFactor = EH;
		break;
	case EH:
		T->balFactor = RH;
		T1->balFactor = LH;
		break;
	}
	T = T1;
}

void rotateLR(AVLTree& T) // quay kép LR
{
	AVLNode* T1 = T->Left;
	AVLNode* T2 = T1->Right;
	T->Left = T2->Right;
	T2->Right = T;
	T1->Right = T2->Left;
	T2->Left = T1;
	switch (T2->balFactor)
	{
	case LH:
		T->balFactor = RH;
		T1->balFactor = EH;
		break;
	case EH:
		T->balFactor = EH;
		T1->balFactor = EH;
		break;
	case RH:
		T->balFactor = EH;
		T1->balFactor = LH;
		break;
	}
	T2->balFactor = EH;
	T = T2;
}

void rotateRL(AVLTree& T) // quay kép RL
{
	AVLNode* T1 = T->Right;
	AVLNode* T2 = T1->Left;
	T->Right = T2->Left;
	T2->Left = T;
	T1->Left = T2->Right;
	T2->Right = T1;
	switch (T2->balFactor)
	{
	case RH:
		T->balFactor = LH; T1->balFactor = EH; break;
	case EH:
		T->balFactor = EH; T1->balFactor = EH; break;
	case LH:
		T->balFactor = EH; T1->balFactor = RH; break;
	}
	T2->balFactor = EH;
	T = T2;
}

int balanceLeft(AVLTree& T)
{
	// cân bằng khi cây bị lệch về bên trái
	AVLNode* T1 = T->Left;

	switch (T1->balFactor)
	{
	case LH: rotateLL(T); return 2;
	case EH: rotateLL(T); return 1;
	case RH: rotateLR(T); return 2;
	}
	return 0;
}

int balanceRight(AVLTree& T)
{
	// cân bằng khi cây bị lệch về bên phải
	AVLNode* T1 = T->Right;

	switch (T1->balFactor)
	{
	case LH: rotateRL(T); return 2;
	case EH: rotateRR(T); return 1;
	case RH: rotateRR(T); return 2;
	}
	return 0;
}

int balance(AVLTree& T)
{
	int bf = T->balFactor;

	if (bf == LH)
	{
		AVLNode* T1 = T->Left;
		switch (T1->balFactor)
		{
		case LH: rotateLL(T); return 2;
		case EH: rotateLL(T); return 1;
		case RH: rotateLR(T); return 2;
		}
	}
	else if (bf == RH)
	{
		AVLNode* T1 = T->Right;
		switch (T1->balFactor)
		{
		case LH: rotateRL(T); return 2;
		case EH: rotateRR(T); return 1;
		case RH: rotateRR(T); return 2;
		}
	}

	return 0;
}
// thêm một phần tử trên cây AVL
int InsertNode(AVLTree& T, int x)
{
	int Res;
	if (T)
	{
		//gia tri da co trong cay
		if (T->Info == x) return 0;

		//T->Info > x
		//chen vao ben trai
		if (T->Info > x)
		{
			Res = InsertNode(T->Left, x);
			if (Res < 2) return Res;

			//Res >= 2
			switch (T->balFactor)
			{
			case RH:
				T->balFactor = EH;
				return 1;
			case EH:
				T->balFactor = LH;
				return 2;
			case LH:
				balanceLeft(T);
				return 1;
			}
		}

		//T->Info < x
		//chen vao ben phai
		else
		{
			Res = InsertNode(T->Right, x);

			if (Res < 2) return Res;

			//Res >= 2
			switch (T->balFactor)
			{
			case LH:
				T->balFactor = EH;
				return 1;
			case EH:
				T->balFactor = RH;
				return 2;
			case RH:
				balanceRight(T);
				return 1;
			}
		}
	}
	T = CreateAVLNode(x);
	return 2;
}
///tim x match voi node
//Tim node the mang
int searchstandfor(AVLNode*& p, AVLNode*& q) // Tìm kiếm giá trị cần xóa
{
	int ketqua;
	if (q->Left != NULL) ///nếu con trỏ đi qua trái khác rỗng thì kết quả sẽ bằng kết quả tìm kiếm ở trái
	{
		ketqua = searchstandfor(p, q->Left); // Kết quả bằng giá trị Node q bên trái
		if (ketqua < 2)
			return ketqua;   // Nếu giá trị tìm thấy thì trả về 1 còn không tiếp tục tìm kiếm 
		switch (q->balFactor)  // Xét về giá trị chiều cao cây Node q
		{
		case LH:			// Nếu Node q bên  trái lệch cao hơn thì tiếp tục tìm kiếm bên phải
			q->balFactor = EH;
			return 2;
		case EH:		// Nếu cây con trái bằng với cây con phải thì dừng tìm kiếm bên phải và qua tìm kiếm bên trái.
			q->balFactor = RH;
			return 1;
		case RH:		// Nếu Node q bên phải lệnh cao hơn thì cân bằng lại node q bên phải
			return balanceRight(q);
		}
	}
	else  // Nếu dò đến lúc hết giá trị
	{
		p->Info = q->Info; // Giá trị Node p = Giá trị Node q;
		p = q; // Node p = Node q;
		q = q->Right;  // Node q sẽ bằng bên phải của Node q;
	}
	return 2; // Tiếp tục tìm kiếm.
}
///xoa node
int deleteAVLNode(AVLNode*& T, ItemType x) // Xóa giá trị cần tìm
{
	int ketqua;
	if (T == NULL) // Nếu Cây T rỗng thì trả về không có giá trị
		return 0;
	if (T->Info > x) // Nếu Giá trị T lớn hơn giá trị x cần tìm
	{
		ketqua = deleteAVLNode(T->Left, x); // Tiếp tục tìm phía bên trái Node T
		if (ketqua < 2)
			return ketqua;  // Nếu kết quả nhỏ hơn 2 => trả về giá trị tìm thấy
		switch (T->balFactor)
		{
		case LH:		// Nếu Node T bên  trái lệch cao hơn thì tiếp tục tìm kiếm bên phải
			T->balFactor = EH;
			return 2;
		case EH:		// Nếu cây con trái bằng với cây con phải thì dừng tìm kiếm bên phải và qua tìm kiếm bên trái						
			T->balFactor = RH;
			return 1;
		case RH:		// Nếu Node T bên phải lệnh cao hơn thì cân bằng lại node T bên phải
			return balanceRight(T);

		}
	}
	else if (T->Info < x) // Nếu giá trị node T nhỏ hơn x 
	{
		ketqua = deleteAVLNode(T->Right, x); // giá trị kết quả gán tìm kiếm tiếp bên tay phải
		if (ketqua < 2)
			return ketqua;	// Nếu kết quả tìm thấy sẽ dừng lại 
		switch (T->balFactor)
		{
		case RH:	// Nếu Node T bên  phải lệch cao hơn thì tiếp tục tìm kiếm bên phải
			T->balFactor = EH;
			return 2;
		case EH:	// Nếu cây con trái bằng với cây con phải thì dừng tìm kiếm bên phải và qua tìm kiếm bên trái	
			T->balFactor = LH;
			return 1;
		case LH:	//  Nếu Node T bên phải lệnh cao hơn thì cân bằng lại node T bên trái 
			return balanceLeft(T);
		}
	}
	else //Nếu không tìm thấy bên phải
	{
		if (T->Left == NULL) // Xét điều kiện nếu Node T bên trái bằng Rỗng
		{
			T = T->Right; //  Node T = Node T bên phải
			ketqua = 2; // Trả về kết quả bằng 2
		}
		else // Còn nếu không rỗng thì
		{
			if (T->Right == NULL) // Xét Điều kiện Node T bên phải bằng Rỗng
			{
				T = T->Left; //  Node T = Node T bên trái
				ketqua = 2; // Trả về kết quả bằng 2
			}
			else // Còn nếu ko thấy
			{
				ketqua = searchstandfor(T, T->Right); // Xét kết quả tìm kiếm giá trị bên phải
				if (ketqua < 2)
					return ketqua; // Nếu kết quả tìm thấy sẽ dừng lại 
				switch (T->balFactor)
				{
				case RH: // Nếu Node T bên  phải lệch cao hơn thì tiếp tục tìm kiếm bên phải
					T->balFactor = EH;
					return 2;
				case EH: // Nếu cây con trái bằng với cây con phải thì dừng tìm kiếm bên phải và qua tìm kiếm bên trái
					T->balFactor = LH;
					return 1;
				case LH: //  Nếu Node T bên phải lệnh cao hơn thì cân bằng lại node T bên trái 
					return balanceLeft(T);
				}
			}
		}
		delete T; // Xóa giá trị Node p đó;
		return ketqua; // Trả về giá trị kết quả để xét điều kiện đã xóa đc hay chưa
	}
	return ketqua; // Trả về giá trị kết quả để xét điều kiện đã xóa đc hay chưa 
}


//Duyet theo muc
void Level(AVLTree T)
{
	queue<AVLTree> q;
	AVLTree p;

	if (T == NULL) return;

	p = T;
	q.push(p);

	while (!q.empty())
	{
		p = q.front();
		q.pop();
		cout << p->Info << endl;

		if (p->Left) q.push(p->Left);
		if (p->Right) q.push(p->Right);
	}
}
void traverseNLR(AVLNode* root)
{
	if (root == NULL)
		return;
	printf("%4d", root->Info);
	traverseNLR(root->Left);
	traverseNLR(root->Right);
}
AVLNode* findTNode(AVLNode* root, ItemType x)
{
	if (root == NULL)
		return NULL;
	if (root->Info == x)
		return root;
	else if (root->Info > x)
		return findTNode(root->Left, x);
	else
		return findTNode(root->Right, x);
}

void displayMenu()
{
	cout << "=== MENU ===" << endl;
	cout << "1. Tao Node " << endl;
	cout << "2. Xuat Node " << endl;
	cout << "3. Xoa Node " << endl;
	cout << "4. Tim Node" << endl;
	cout << "5. Thoat" << endl;
	cout << "vui long nhap lua chon (1-5): ";
}

void main()
{
	AVLTree T;
	CreateAVLTree(T);
	int luachon;
	do
	{
		displayMenu();
		cout << "Vui long nhap lua chon" << endl;
		cin >> luachon;
		switch (luachon)
		{
		case 1:
		{
			int value;
			do
			{
				cout << "Nhap node: " ;
				cin >> value;
				if (InsertNode(T, value)!=-999)
					cout << "nhap node thanh cong" << endl;
			} while (value != -999);
			break;
		}
		case 2:
		{
			cout << "Xuat cay theo tung node lan luot theo NLR la" << endl;
			traverseNLR(T);
			break;
		}
		case 3:
		{
			int value;
			cout << "Nhap gia tri de xoa" << endl;
			cin >> value;
			if (deleteAVLNode(T, value))
				cout << "Xoa thanh cong" << endl;
			else
				cout << "Gia tri chua tim thay" << endl;
			break;
		}
		case 4:
		{
			int value;
			cout << "Tim Node" << endl;
			cin >> value;
			if (findTNode(T, value) != NULL)
				cout << "Gia tri %d tim thay cua tren cay " << value << endl;
			else
				cout << "Gia tri khong ton tai";
			break;
		}
		case 5:
		{
			exit(1);
			break;
		}

		}
	} while (1);
	_getch();
}

