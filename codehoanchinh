#include<stdio.h>
#include<iostream>
#include<queue>
#include<conio.h>
using namespace std;

#define RH 1 // cÃ¢y con pháº£i cao hÆ¡n ( lá»‡ch pháº£i )
#define EH 0 // cÃ¢y con trÃ¡i báº±ng cÃ¢y con pháº£i ( cÃ¢n báº±ng )
#define LH -1 // cÃ¢y con trÃ¡i cao hÆ¡n ( lá»‡ch trÃ¡i

typedef int ItemType;

struct AVLNode
{
	int balFactor; // chá»‰ sá»‘ cÃ¢n báº±ng
	ItemType Info;
	AVLNode* Right;
	AVLNode* Left;
};

typedef struct AVLNode* AVLTree;

// khoi tao cay
void CreateAVLTree(AVLTree& T)
{
	T = NULL;
}

AVLNode* CreateAVLNode(int x)
{
	AVLNode* p = new AVLNode;

	if (!p) exit(1);

	p->balFactor = EH;
	p->Info = x;
	p->Left = NULL;
	p->Right = NULL;

	return p;
}

void rotateLL(AVLTree& T) // quay Ä‘Æ¡n LL
{
	AVLNode* T1 = T->Left;
	T->Left = T1->Right;
	T1->Right = T;
	switch (T1->balFactor)
	{
	case LH:
		T->balFactor = EH;
		T1->balFactor = EH;
		break;
	case EH:
		T->balFactor = LH;
		T1->balFactor = RH;
		break;
	}
	T = T1;
}

void rotateRR(AVLTree& T) // quay Ä‘Æ¡n RR
{
	AVLNode* T1 = T->Right;
	T->Right = T1->Left;
	T1->Left = T;
	switch (T1->balFactor)
	{
	case RH:
		T->balFactor = EH;
		T1->balFactor = EH;
		break;
	case EH:
		T->balFactor = RH;
		T1->balFactor = LH;
		break;
	}
	T = T1;
}

void rotateLR(AVLTree& T) // quay kÃ©p LR
{
	AVLNode* T1 = T->Left;
	AVLNode* T2 = T1->Right;
	T->Left = T2->Right;
	T2->Right = T;
	T1->Right = T2->Left;
	T2->Left = T1;
	switch (T2->balFactor)
	{
	case LH:
		T->balFactor = RH;
		T1->balFactor = EH;
		break;
	case EH:
		T->balFactor = EH;
		T1->balFactor = EH;
		break;
	case RH:
		T->balFactor = EH;
		T1->balFactor = LH;
		break;
	}
	T2->balFactor = EH;
	T = T2;
}

void rotateRL(AVLTree& T) // quay kÃ©p RL
{
	AVLNode* T1 = T->Right;
	AVLNode* T2 = T1->Left;
	T->Right = T2->Left;
	T2->Left = T;
	T1->Left = T2->Right;
	T2->Right = T1;
	switch (T2->balFactor)
	{
	case RH:
		T->balFactor = LH; T1->balFactor = EH; break;
	case EH:
		T->balFactor = EH; T1->balFactor = EH; break;
	case LH:
		T->balFactor = EH; T1->balFactor = RH; break;
	}
	T2->balFactor = EH;
	T = T2;
}

int balance(AVLTree& T)
{
	int bf = T->balFactor;

	if (bf == LH)
	{
		AVLNode* T1 = T->Left;
		switch (T1->balFactor)
		{
		case LH: rotateLL(T); return 2;
		case EH: rotateLL(T); return 1;
		case RH: rotateLR(T); return 2;
		}
	}
	else if (bf == RH)
	{
		AVLNode* T1 = T->Right;
		switch (T1->balFactor)
		{
		case LH: rotateRL(T); return 2;
		case EH: rotateRR(T); return 1;
		case RH: rotateRR(T); return 2;
		}
	}

	return 0;
}

int balanceLeft(AVLTree& T)
{
	AVLNode* T1 = T->Left;

	if (T1->balFactor == LH)
	{
		rotateLL(T);
		return 1;
	}
	else if (T1->balFactor == EH)
	{
		rotateLL(T);
		return 2;
	}
	else if (T1->balFactor == RH)
	{
		rotateLR(T);
		return 1;
	}

	return 0;
}

int balanceRight(AVLTree& T)
{
	AVLNode* T1 = T->Right;

	if (T1->balFactor == RH)
	{
		rotateRR(T);
		return 1;
	}
	else if (T1->balFactor == EH)
	{
		rotateRR(T);
		return 2;
	}
	else if (T1->balFactor == LH)
	{
		rotateRL(T);
		return 1;
	}

	return 0;
}
// thÃªm má»™t pháº§n tá»­ trÃªn cÃ¢y AVL
int InsertNode(AVLTree& T, int x)
{
	int Res;
	if (T)
	{
		//gia tri da co trong cay
		if (T->Info == x) return 0;

		//Root->x > x
		//chen vao ben trai
		if (T->Info > x)
		{
			Res = InsertNode(T->Left, x);
			if (Res < 2) return Res;

			//Res >= 2
			switch (T->balFactor)
			{
			case RH:
				T->balFactor = EH;
				return 1;
			case EH:
				T->balFactor = LH;
				return 2;
			case LH:
				balanceLeft(T);
				return 1;
			}
		}

		//Root->x < x
		//chen vao ben phai
		else
		{
			Res = InsertNode(T->Right, x);

			if (Res < 2) return Res;

			//Res >= 2
			switch (T->balFactor)
			{
			case LH:
				T->balFactor = EH;
				return 1;
			case EH:
				T->balFactor = RH;
				return 2;
			case RH:
				balanceRight(T);
				return 1;
			}
		}
	}

	T = CreateAVLNode(x);
	return 2;
}

///tim x match voi node
//Tim node the mang
int SearchStandFor(AVLTree& T, AVLNode*& p)
{
	int Res;

	if (p->Left)
	{
		Res = SearchStandFor(T, p->Left);

		if (Res < 2) return Res;

		switch (p->balFactor)
		{
		case LH:
			p->balFactor = EH;
			return 1;
		case EH:
			p->balFactor = RH;
			return 2;
		case RH:
			return balanceRight(T);
		}
	}
	T->Info = p->Info;
	T = p;
	p = p->Right;
	return 2;
}

//Xoa 1 node tren cay
int DelNode(AVLTree& T, int x)
{
	int Res;

	//Khong ton tai node nay tren cay
	if (!T) return 0;

	//Qua duoc if tren tuc la ton tai
	//Root->x > x => Sang ben trai tim xoa
	if (T->Info > x)
	{
		Res = DelNode(T->Left, x);

		//Neu co xoa thi Res = 1 hoac 2. 2 tuc thay doi chieu cao cay
		if (Res < 2) return Res;

		//Chieu cao bi thay doi
		switch (T->balFactor)
		{
		case LH:
			T->balFactor = EH;
			return 2;
		case EH:
			T->balFactor = RH;
			return 1;
		case RH:
			return balanceRight(T);
		}
	}

	if (T->Info < x)
	{
		Res = DelNode(T->Right, x);

		if (Res < 2) return Res;

		switch (T->balFactor)
		{
		case LH:
			return balanceLeft(T);
		case EH:
			T->balFactor = LH;
			return 1;
		case RH:
			T->balFactor = EH;
			return 2;
		}
	}
	else
	{
		//Root->x = x
		AVLNode* p1 = T;

		if (T->Left == NULL)
		{
			T = T->Right;
			Res = 2;
		}
		else
		{
			if (T->Right == NULL)
			{
				T = T->Left;
				Res = 2;
			}
			else
			{
				Res = SearchStandFor(p1, T->Right);

				if (Res < 2) return Res;
				switch (T->balFactor)
				{
				case RH:
					T->balFactor = EH;
					return 2;
				case EH:
					T->balFactor = LH;
					return 1;
				case LH:
					return balanceRight(T);
				}
			}
			delete p1;
			return Res;
		}
	}

}

//Duyet theo muc
void Level(AVLTree T)
{
	queue<AVLTree> q;
	AVLTree p;

	if (T == NULL) return;

	p = T;
	q.push(p);

	while (!q.empty())
	{
		p = q.front();
		q.pop();
		cout << p->Info << endl;

		if (p->Left) q.push(p->Left);
		if (p->Right) q.push(p->Right);
	}
}

void Input(AVLTree& Root)
{
	int x;
	do
	{
		cout << "x = 0 de thoat: x = ";
		cin >> x;
		if (x == 0) break;
		InsertNode(Root, x);
	} while (1);
}

void main() 
{
	AVLTree T;
	CreateAVLTree(T);
	int luachon, value;
	while (true) {
		cout << "\n\n AVL TREE MENU\n";
		cout << "1. Tạo  node\n";
		cout << "2. Delete node\n";
		cout << "3. Tìm node\n";
		cout << "4. Cân Bằng Cây \n";
		cout << "5. Thoát \n";
		cout << "Vui Lòng Nhập lựa chọn: ";
		cin >> luachon;

		switch (luachon) {
		case 1:
			cout << "Nhập Node: ";
			cin >> value;
			if (InsertNode(T, value) == 1)
				cout << "Nhập Node Thành Công\n";
			else
				cout << "Giá trị này đã có trong cây\n";
			break;
		case 2:
			cout << "Nhập giá trị để xoá: ";
			cin >> value;
			if (DelNode(T, value) == 1)
				cout << "Xoá Thành Công \n";
			else
				cout << "Giá Trị Không Tìm Thấy \n";
			break;
		case 3:
			cout << "Tìm Node: ";
			cin >> value;
			if (Input(T) == NULL)
				cout << "Node Không Tồn Tại Trong cây\n";
			else
				cout << "Giá trị này là \n";
			break;
		case 4:
			balance(T);
			cout << "Cây đã cân bằng thành công \n";
			break;
		case 5:
			exit(0);
		default:
			cout << "Lựa chọn không hợp lệ\n";
		}
	}
}
